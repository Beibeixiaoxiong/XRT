#include"Graphlnk.h"
void printPath(Graphlnk& G, int v, int dist[], int path[])
{
//输出path数组中存储的图G从顶点v到其余各顶点的路径和距离
	cout  << G.NodeTable[v].start << "的路由表为" << endl;
	int i, j, k, n = G.numVertices;
	int * d = new int[n];
	for (i = 0; i<n; i++)
	{
		if (i != v)
		{
			j = i;
			k = 0;
			while (j != v)
			{
				d[k++] = j;
				j = path[j];
			}
		//	cout << "顶点" << G.NodeTable[i].start << "的最短路径为：" << G.NodeTable[v].start << " ";
		        
			
				if(k==1) 
				{
				cout << "目的网络"<<G.NodeTable[d[0]].start<< " ";
				cout<<"直接交付"<<" ";
			}
				else
				{
					cout << "目的网络"<<G.NodeTable[d[0]].start<< " ";
				cout<<"下一跳"<<G.NodeTable[d[k-1]].start<<" ";
}
			 cout << "最短路径长度为：" << dist[i] << endl;
		}
	}
	delete[] d;
}

void ShortestPath(Graphlnk& G, int v, int dist[], int path[])
{//Graph是一个带权有向图，本算法建立一个数组，dist[j],0<=j<n;是当前求到的从顶点v到顶点j的最短路径长度，同时用数组path存放求到的最短路径
	int n = G.numVertices;
	bool *S = new bool[n];
	int i, j, k;
	int w, min;
	for (i = 0; i<n; i++)
	{
		dist[i] = G.getWeight(v, i);
		S[i] = false;
		
		if (i != v && dist[i] <100)
			path[i] = v;
		else
		{
			path[i] = -1;
		}
	}
	S[v] = true;
	dist[v] = 0;
	for (i = 0; i<n - 1; i++)
	{
		min = 100;
		int u = v;
		for (j = 0; j<n; j++)
		{
			if (S[j] == false && dist[j] < min)
			{
				u = j;
				min = dist[j];
			}
		}
		S[u] = true;
		for (k = 0; k<n; k++)
		{
			w = G.getWeight(u, k);
			if (S[k] == false && w <100&& dist[u] + w<dist[k])
			{
				dist[k] = dist[u] + w;
				path[k] = u;
			}
		}
	}
	printPath(G, v, dist, path);
}
int main()
{
Graphlnk G(30);
cout<<"读取文件插入站点" <<endl;
G.insertVertex();
cout<<"总站点数为"<<G.numVertices<<endl;
int i,j,weight;
ifstream fin("C:\\2.txt", std::ios::in);
char line[1024]={0};
string x="";
string y="";
string m="";
string n="";
int z;
while(fin.getline(line, sizeof(line)))
{
stringstream word(line);
word >> x;//路由起点 
word >> y;//路由终点 
word >> z;//权值 
word >> m;//网络号 
word >> n;//子网掩码 
i=G.getVertexPos(x);
j=G.getVertexPos(y);
weight=z;
G.insertEdge(i,j,weight,m,n);
}

fin.clear();
fin.close();
cout<<"总边数数为"<<G.numEdges<<endl;
int h;
	 int r;
	int *dist= new int[G.numVertices];
	 int *path= new int[G.numEdges];
	 string v,u;int a=1,b;
	//输出路由表 

	while(a)
	{
	 cout<<"1.输入路由号显示路由表  2.删除一个路由表  3.删除一条边 4.退出"<<endl; 
	 cin>>b;
	 if(b==1)
	 {	  
	 cout<<"输入路由号"<<endl; 
	 cin>>v;
	 r=G.getVertexPos(v);
	 while(r==-1)
	 {
	 	cout<<"没有该路由"<<endl;
	 	cout<<"输入路由器"<<endl;
	    cin>>v;
	    r=G.getVertexPos(v);
	 }
	  
	 ShortestPath(G, r, dist, path);
}
if(b==2)
{
	
 //删除一个路由器 
	cout<<"删除路由器"<<endl;
	cin>>v;
	int w=G.getVertexPos(v);
	while(!G.removeVertex(w))
	{
		cout<<"没有该路由"<<endl;
		cout<<"删除路由器"<<endl;
	    cin>>v;
		w=G.getVertexPos(v);
	}	
	cout<<"已生成新的路由表"<<" "<<"输入路由器查看路由表"<<endl;
	 cin>>v;
	  r=G.getVertexPos(v);
	 if(r==-1)
	 {
	 	cout<<"没有该路由"<<endl;
	 }
	 else
	 {	 
	 ShortestPath(G, r, dist, path);
     }	
}
if(b==3)
{
	 //删除一条边 
        cout<<"删除一条边"<<endl;
		cin>>v;
		cin>>u;
		r=G.getVertexPos(v);
		h=G.getVertexPos(u);
		while(!G.removeEdge(r,h))
		{
		cout<<"删除一条边"<<endl;
		cin>>v;
		cin>>u;
		r=G.getVertexPos(v);
		h=G.getVertexPos(u);
		}
	
}
if(b==4)
 {
a=0;
cout<<"已退出"<<endl;
}

} 
	 
}
